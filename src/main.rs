#![feature(test)]
#![feature(peek)]

use std::{thread, time};
use std::net::{TcpListener, TcpStream, UdpSocket};
use std::io::{Write, Read};
use std::fs::File;
use std::process::{Command, Stdio};

static MAGIC_BYTES_CTRL: &'static [u8] = &[
    0x49, 0x54, 0x64, 0x00, 0x00, 0x00, 0x5D, 0x00, 0x00, 0x00, 0x81, 0x85, 0xFF, 0xBD, 0x2A, 0x29,
    0x5C, 0xAD, 0x67, 0x82, 0x5C, 0x57, 0xBE, 0x41, 0x03, 0xF8, 0xCA, 0xE2, 0x64, 0x30, 0xA3, 0xC1,
    0x5E, 0x40, 0xDE, 0x30, 0xF6, 0xD6, 0x95, 0xE0, 0x30, 0xB7, 0xC2, 0xE5, 0xB7, 0xD6, 0x5D, 0xA8,
    0x65, 0x9E, 0xB2, 0xE2, 0xD5, 0xE0, 0xC2, 0xCB, 0x6C, 0x59, 0xCD, 0xCB, 0x66, 0x1E, 0x7E, 0x1E,
    0xB0, 0xCE, 0x8E, 0xE8, 0xDF, 0x32, 0x45, 0x6F, 0xA8, 0x42, 0xEE, 0x2E, 0x09, 0xA3, 0x9B, 0xDD,
    0x05, 0xC8, 0x30, 0xA2, 0x81, 0xC8, 0x2A, 0x9E, 0xDA, 0x7F, 0xD5, 0x86, 0x0E, 0xAF, 0xAB, 0xFE,
    0xFA, 0x3C, 0x7E, 0x54, 0x4F, 0xF2, 0x8A, 0xD2, 0x93, 0xCD
];
static MAGIC_BYTES_VIDEO_1_1: &'static [u8] = &[
    0x49, 0x54, 0x64, 0x00, 0x00, 0x00, 0x52, 0x00, 0x00, 0x00, 0x0F, 0x32, 0x81, 0x95, 0x45, 0x2E,
    0xF5, 0xE1, 0xA9, 0x28, 0x10, 0x86, 0x63, 0x17, 0x36, 0xC3, 0xCA, 0xE2, 0x64, 0x30, 0xA3, 0xC1,
    0x5E, 0x40, 0xDE, 0x30, 0xF6, 0xD6, 0x95, 0xE0, 0x30, 0xB7, 0xC2, 0xE5, 0xB7, 0xD6, 0x5D, 0xA8,
    0x65, 0x9E, 0xB2, 0xE2, 0xD5, 0xE0, 0xC2, 0xCB, 0x6C, 0x59, 0xCD, 0xCB, 0x66, 0x1E, 0x7E, 0x1E,
    0xB0, 0xCE, 0x8E, 0xE8, 0xDF, 0x32, 0x45, 0x6F, 0xA8, 0x42, 0xB7, 0x33, 0x0F, 0xB7, 0xC9, 0x57,
    0x82, 0xFC, 0x3D, 0x67, 0xE7, 0xC3, 0xA6, 0x67, 0x28, 0xDA, 0xD8, 0xB5, 0x98, 0x48, 0xC7, 0x67,
    0x0C, 0x94, 0xB2, 0x9B, 0x54, 0xD2, 0x37, 0x9E, 0x2E, 0x7A
];
static MAGIC_BYTES_VIDEO_1_2: &'static [u8] = &[
    0x49, 0x54, 0x64, 0x00, 0x00, 0x00, 0x52, 0x00, 0x00, 0x00, 0x54, 0xB2, 0xD1, 0xF6, 0x63, 0x48,
    0xC7, 0xCD, 0xB6, 0xE0, 0x5B, 0x0D, 0x1D, 0xBC, 0xA8, 0x1B, 0xCA, 0xE2, 0x64, 0x30, 0xA3, 0xC1,
    0x5E, 0x40, 0xDE, 0x30, 0xF6, 0xD6, 0x95, 0xE0, 0x30, 0xB7, 0xC2, 0xE5, 0xB7, 0xD6, 0x5D, 0xA8,
    0x65, 0x9E, 0xB2, 0xE2, 0xD5, 0xE0, 0xC2, 0xCB, 0x6C, 0x59, 0xCD, 0xCB, 0x66, 0x1E, 0x7E, 0x1E,
    0xB0, 0xCE, 0x8E, 0xE8, 0xDF, 0x32, 0x45, 0x6F, 0xA8, 0x42, 0xB7, 0x33, 0x0F, 0xB7, 0xC9, 0x57,
    0x82, 0xFC, 0x3D, 0x67, 0xE7, 0xC3, 0xA6, 0x67, 0x28, 0xDA, 0xD8, 0xB5, 0x98, 0x48, 0xC7, 0x67,
    0x0C, 0x94, 0xB2, 0x9B, 0x54, 0xD2, 0x37, 0x9E, 0x2E, 0x7A
];
static MAGIC_BYTES_VIDEO_2: &'static [u8] = &[
    0x49, 0x54, 0x64, 0x00, 0x00, 0x00, 0x58, 0x00, 0x00, 0x00, 0x80, 0x86, 0x38, 0xC3, 0x8D, 0x13,
    0x50, 0xFD, 0x67, 0x41, 0xC2, 0xEE, 0x36, 0x89, 0xA0, 0x54, 0xCA, 0xE2, 0x64, 0x30, 0xA3, 0xC1,
    0x5E, 0x40, 0xDE, 0x30, 0xF6, 0xD6, 0x95, 0xE0, 0x30, 0xB7, 0xC2, 0xE5, 0xB7, 0xD6, 0x5D, 0xA8,
    0x65, 0x9E, 0xB2, 0xE2, 0xD5, 0xE0, 0xC2, 0xCB, 0x6C, 0x59, 0xCD, 0xCB, 0x66, 0x1E, 0x7E, 0x1E,
    0xB0, 0xCE, 0x8E, 0xE8, 0xDF, 0x32, 0x45, 0x6F, 0xA8, 0x42, 0xEB, 0x20, 0xBE, 0x38, 0x3A, 0xAB,
    0x05, 0xA8, 0xC2, 0xA7, 0x1F, 0x2C, 0x90, 0x6D, 0x93, 0xF7, 0x2A, 0x85, 0xE7, 0x35, 0x6E, 0xFF,
    0xE1, 0xB8, 0xF5, 0xAF, 0x09, 0x7F, 0x91, 0x47, 0xF8, 0x7E
];
static MAGIC_BYTES_HEARTBEAT: &'static [u8] = &[
    0x49, 0x54, 0x64, 0x00, 0x00, 0x00, 0x52, 0x00, 0x00, 0x00, 0xeb, 0xdf, 0xee, 0xab, 0x01, 0x76,
    0x64, 0x3e, 0x47, 0x07, 0x60, 0x2d, 0xe5, 0xe9, 0x86, 0x59, 0xac, 0xef, 0x63, 0xf7, 0x71, 0x57,
    0xab, 0x2f, 0x53, 0xe3, 0xf7, 0x68, 0xec, 0xd9, 0xe1, 0x85, 0x47, 0xb8, 0xc2, 0x2e, 0x21, 0xd0,
    0x1b, 0xfb, 0x6b, 0x3d, 0xe3, 0x25, 0xa2, 0x7b, 0x8f, 0xb3, 0xac, 0xef, 0x63, 0xf7, 0x71, 0x57,
    0xab, 0x2f, 0x53, 0xe3, 0xf7, 0x68, 0xec, 0xd9, 0xe1, 0x85, 0xb7, 0x33, 0x0f, 0xb7, 0xc9, 0x57,
    0x82, 0xfc, 0x3d, 0x67, 0xe7, 0xc3, 0xa6, 0x67, 0x28, 0xda, 0xd8, 0xb5, 0x98, 0x48, 0xc7, 0x67,
    0x0c, 0x94, 0xb2, 0x9b, 0x54, 0xd2, 0x37, 0x9e, 0x2e, 0x7a
];
static GAMEPAD_DATA: &'static [u8] = &[
    0xCC, 0x7F, 0x7F, 0x0, 0x7F, 0x0, 0x7F, 0x33
];

fn main() {
    connect_drone();
//    save_screenshot();
}

fn connect_drone() {
//    create_local_video();
    connect_controls();
    connect_video_1();
}

fn connect_controls() {
    if let Ok(stream) = TcpStream::connect("172.16.10.1:8888") {
        println!("Connected to the controls! {:?}", stream);
        send_magic_packets(&stream);

        thread::spawn(move || {
            println!("Created gamepad thread");
            connect_gamepad();
        });
    } else {
        println!("Couldn't connect to controls...");
    }
}

fn connect_video_1() {
    if let Ok(stream) = TcpStream::connect("172.16.10.1:8888") {
        println!("Connected to the video 1! {:?}", stream);
        let magic_video_idx: i8 = 0;
        send_magic_packets_video_1(&stream, magic_video_idx);
    } else {
        println!("Couldn't connect to video 1...");
    }
}

fn connect_video_2() {
    if let Ok(stream) = TcpStream::connect("172.16.10.1:8888") {
        println!("Connected to the video 2! {:?}", stream);
        send_magic_packets_video_2(&stream);
    } else {
        println!("Couldn't connect to video 2...");
    }
}

fn connect_heartbeat() {
    if let Ok(stream) = TcpStream::connect("172.16.10.1:8888") {
        println!("Connected to heartbeat! {:?}", stream);

        thread::spawn(move || {
            println!("Created heartbeat thread");
            send_heartbeat(&stream);
        });
    } else {
        println!("Couldn't connect to heartbeat...");
    }
}

fn connect_gamepad() {
    if let Ok(socket) = UdpSocket::bind("0.0.0.0:0") {
        println!("Bound to gamepad! {:?}", socket);
        send_gamepad_data(&socket);
    } else {
        println!("Couldn't connect to gamepad...");
    }
}

fn connect_local_video(input_stream: &TcpStream) {
    if let Ok(stream) = TcpStream::connect("127.0.0.1:8889") {
        println!("Bound to local video! {:?}", stream);
        connect_heartbeat();
        listen_video_2(&input_stream, &stream);
    } else {
        println!("Couldn't connect to local video...");
    }
}

fn send_magic_packets(mut stream: &TcpStream) {
    stream.write(MAGIC_BYTES_CTRL);
    println!("Sent magic packets ctrl");
}

fn send_magic_packets_video_1(mut stream: &TcpStream, mut magic_video_idx: i8) {
    magic_video_idx = magic_video_idx + 1;

    if magic_video_idx == 1 {
        stream.write(MAGIC_BYTES_VIDEO_1_1);
        println!("Sent magic packets video 1 2");
        send_magic_packets_video_1(&stream, magic_video_idx);
    } else {
        stream.write(MAGIC_BYTES_VIDEO_1_2);
        println!("Sent magic packets video 1 2");
        connect_video_2();
    }
}

fn send_magic_packets_video_2(mut stream: &TcpStream) {
    stream.write(MAGIC_BYTES_VIDEO_2);
    println!("Sent magic packets video 2");

    connect_local_video(&stream);
}

fn send_gamepad_data(mut socket: &UdpSocket) {
    socket.send_to(GAMEPAD_DATA, "172.16.10.1:8895");
    println!("Sent gamepad data");
}

fn send_heartbeat(mut stream: &TcpStream) {
    loop {
        let interval = time::Duration::from_secs(5);
        thread::sleep(interval);

        stream.write(MAGIC_BYTES_HEARTBEAT);
        println!("Sent heartbeat");

        listen_heartbeat(&stream);
    }
}

fn listen_heartbeat(mut stream: &TcpStream) {
    let mut buffer = [0; 8192];
    let mut buffer_size = 0;

    match stream.take_error() {
        Ok(_) => (),
        Err(e) => println!("Received heartbeat err: {:?}", e),
    }

    match stream.read(&mut buffer[..]) {
        Ok(size) => buffer_size = size,
        Err(e) => println!("Error reading heartbeat: {:?}", e),
    }

    println!("Received heartbeat with length: {}", buffer_size);
}

fn listen_video_2(mut input_stream: &TcpStream, mut output_stream: &TcpStream) {
    loop {
        let mut buffer = [0; 8192];
        let mut buffer_size = 0;

        match input_stream.take_error() {
            Ok(_) => (),
            Err(e) => println!("Received err: {:?}", e),
        }

        match input_stream.read(&mut buffer[..]) {
            Ok(size) => buffer_size = size,
            Err(e) => println!("Error reading stream: {:?}", e),
        }

        if buffer_size > 0 && buffer_size != 106 {
            println!("Buffer size video 2: {:?}", buffer_size);
            output_stream.write(&buffer[0..buffer_size]);
        }
    }
}

fn listen_local_video(mut stream: &TcpStream) {
    const LEN: usize = 1000000;
    let mut data = [0; LEN];
    let mut data_idx = 0;
    let mut idx = 0;

    let mut buffer = [0; 8192];
    let mut buffer_size = 0;

    loop {
        match stream.read(&mut buffer[..]) {
            Ok(size) => buffer_size = size,
            Err(e) => println!("Error reading stream: {:?}", e),
        }

        if data_idx < LEN {
            for i in 0..buffer_size {
                if data_idx < LEN {
                    data[data_idx] = buffer[i];
                }
                data_idx = data_idx + 1;

                if data_idx >= LEN {
                    write_file(&data);
                    break;
                }
            }
        }

        idx = idx + 1;
        println!("{}", idx);
    }
}

fn write_file(data: &[u8]) {
    let mut file = File::create(format!("./out/data-{}.h264", data[0])).unwrap();
    file.write(&data);
    println!("File written: {:?}", file);
}

fn create_local_video() {
    thread::spawn(move || {
        let server = TcpListener::bind("127.0.0.1:8889").unwrap();
        println!("Created local video accepting thread");

//        Command::new("ffplay")
//            .arg("tcp://127.0.0.1:8889")
//            .arg("-loglevel")
//            .arg("trace")
//            .arg("-f")
//            .arg("h264")
//            .stdout(Stdio::piped())
//            .spawn();

        loop {
//            let result = server.accept();
//
//            if result.is_ok() {
//                let (mut socket, addr) = result.ok().unwrap();
//                println!("Accepted local video! {:?}", socket);
////                let mut _socket = socket.try_clone().unwrap();
////                thread::spawn(move || listen_local_video(&socket));
//            } else if result.is_err() {
//                println!("Could not get client: {:?}", result.err().unwrap());
//            }
        }
    });
}